\chapter{DESENVOLVIMENTO}\label{chap:desenvolvimento}

\section{Seleção de Literatura}

A revisão de literatura foi feita na primeira seção\ldots

\section{Estudo do sensor, prototipagem, testes preliminares}

Utilizamos, inicialmente, um sensor inercial modelo MPU-6050 (Figura~\ref{fig:mpu6050-sensor-top}) anexado a uma Raspberry Pi 3B (Figuras~\ref{fig:mpu6050-board-top}~e~\ref{fig:mpu6050-proto-top}):
\begin{figure}[H]
    \centering
    \caption{Sensor MPU-6050 encapsulado}\label{fig:mpu6050-sensor-top}
    \includegraphics[width=0.5\textwidth]{figuras/mpu6050-sensor-top-straight.jpg}
    \fonte{o autor}
\end{figure}
A orientação dos sensores em relação ao encapsulamento obedece a regra da mão direita, conforme descrito na Figura~\ref{fig:mpu6050-diagram-axis}:
\begin{figure}[H]
    \centering
    \caption{Sensor MPU-6050 eixos em relação ao encapsulamento}\label{fig:mpu6050-diagram-axis}
    \includegraphics[width=0.5\textwidth]{figuras/mpu6050-diagram-axis.jpg}
    \fonte{\citeonline{mpu6050ps}}
\end{figure}
\begin{figure}[H]
    \centering
    \caption{Sensor MPU-6050 montado em placa módulo}\label{fig:mpu6050-board-top}
    \includegraphics[width=0.5\textwidth]{figuras/mpu6050-board-top.jpg}
    \fonte{o autor}
\end{figure}
\begin{figure}[H]
    \centering
    \caption{Sensor MPU-6050 anexado à Raspberry Pi}\label{fig:mpu6050-proto-top}
    \includegraphics[width=0.5\textwidth]{figuras/mpu6050-proto-top.jpg}
    \fonte{o autor}
\end{figure}

Para a programação, utilizamos programação linguagem C para sistema Linux, com metologia ágil e desenvolvimento em código aberto.

\section{Desenvolvimento de Software}

Para operar os sensores inerciais, consultamos extensamente a documentação do fabricante: Especificação do Produto~\cite{mpu6050ps} e Descrição e Mapa de Registradores~\cite{mpu6050rm}.
A partir deles, estabelecemos como requisitos do sistema:
\begin{enumerate}
        \item obter dados simultâneos de todos os sensores em cada amostra,
        \item obter dados em intervalos regulares de tempo,
        \item obter dados em grandezas com significado físico,
        \item permitir o controle da sensibilidade dos sensores,
        \item permitir o controle da taxa de amostragem,
        \item permitir o controle das funções de filtro,
        \item seja utilizável com sistemas operacionais livres e amplamente disponíveis,
        \item possa ser instalado como um programa sem modificar o sistema operacional,
        \item possa ser livremente distribuído com licença de código aberto,
        \item possa ser operado pela linha de comando.
\end{enumerate}

Entretanto, não encontramos nenhuma solução pronta capaz de atender aos nossos requisitos. Nos restou, então, a partir dos manuais, desenvolver programas para controlar o sensor e obter os dados.

Os programas de nossa autoria foram escritos em linguagem C para sistemas Linux, rodam em uma \emph{Raspberry Pi 3B}, estão disponíveis\footnote{O driver em \href{https://www.github.com/ThalesBarretto/libmpu6050}{https://www.github.com/ThalesBarretto/libmpu6050}}\footnote{A biblioteca auxiliar em \href{https://www.github.com/ThalesBarretto/libmtx}{https://www.github.com/ThalesBarretto/libmtx}}\footnote{A aplicação em \href{https://www.github.com/ThalesBarretto/mpu6050}{https://www.github.com/ThalesBarretto/mpu6050}}sob licença permissiva de código aberto\footnote{Sob a ``MIT License'' disponível em \href{https://mit-license.org/}{https://mit-license.org/} e \href{https://opensource.org/licenses/MIT}{https://opensource.org/licenses/MIT}}, e acreditamos atender aos requisitos.

Foram realizados testes de bancada estáticos \ldots

Os resultados foram registrados no formato \ldots

\section{Obtendo dados}

Na prática, os giroscópios  oferecem leituras de \(\mathbf{\omega}^{xyz}_{b/e}\), e os acelerômetros oferecem \(\mathbf{f}^{xyz}\), com eixos dos sensores, \(xyz\), alinhados aos sistemas \(frd\) e \(bf\), todos no quadro \(F^{b}\) do robô e situados no centro de massa. Fixamos um plano tangente à Terra no ponto \(Q\) de interesse, em que colocamos um sistema \(ned\) alinhado com o eixo ``abaixo'' alinhado ao vetor constante \(\mathbf{g}\), e um sistema \(tp\), e consideramos a Terra um referencial inercial (\(F^{i} \equiv F^{e}\equiv F^{tp}\)). Empregamos \(\mathbf{\Phi} \equiv \left[\phi \theta \psi \right]^T \) para descrever a atitude do corpo do robô utilizados ângulos de Euler na sequência anti-horária ``yaw'', ``pitch'', ``roll'' que levam do sistema \(ned\) ao sistema \(frd\).

A orientação do eixo dos sensores em relação ao corpo é fixa de tal modo que:

\begin{align*}
    {{C}_{frd/xyz}} &= {{C}_{xyz/frd}}  = \begin{bmatrix} 1 & 0 & 0 \\ 0 & -1 & 0 \\ 0 & 0 & -1 \end{bmatrix}
\end{align*}


Estabelecemos como condições iniciais, para o instante \(t_{0} = 0\):
\begin{align*}
    {\Phi} \left[0\right] 
        &= \begin{bmatrix} 0 & 0 & 0 \end{bmatrix}^{T} \text{ (veículo nivelado)} \\
    {^{e}{\mathbf{p}^{tp}_{cm/Q}}\left[0\right]}
    &= \begin{bmatrix} 0 & 0 & 0 \end{bmatrix}^{T} \text{ (situado na origem do plano tangente)} \\
    {^{e}{\dot{\mathbf{p}}^{tp}_{cm/Q}}\left[0\right]}
    &= \begin{bmatrix} 0 & 0 & 0 \end{bmatrix}^{T} \text{ (em repouso)} \\
\end{align*}

Utilizamos os giroscópios para obter:
\begin{align*}
     &\mathbf{\omega}^{frd}_{b/e}{\left[k\right]}
     = C_{frd/xyz} \mathbf{\omega}^{xyz}_{b/e}{\left[k\right]}
        \equiv \begin{bmatrix} P{\left[k\right]} & Q{\left[k\right]} & R{\left[k\right]} \end{bmatrix}^{T}
        \text{} \\
\end{align*}

Podemos obter a atitude integrando numericamente:
\begin{align*}
{\Phi}{\left[ k \right]} 
    &\approx {\Phi} {\left[ k-1 \right]} + T {\dot{\Phi}{\left[ k -1 \right]}} \\
    &\approx {\Phi} {\left[ k-1 \right]} + T {\left( H {\left( \Phi{\left[ k-1 \right]} \right)}{\mathbf{\omega}^{frd}_{b/e}}{\left[ k-1 \right]}\right)} \\
\end{align*}

Ou, quando \(\mathbf{a} \approx 0, \equiv \lvert\mathbf{f}\lvert \approx \lvert\mathbf{g}\lvert\), podemos obter \(\theta\) e \(\phi\) dos acelerômetros:
\begin{align*}
    {\phi}\left[k\right] &=  \textrm{atan2}\left(\frac{\mathbf{-f}_{y}}{\mathbf{-f}_{z}}\right),\quad
    -\pi  < \phi \leq \pi \\
    {{\theta}{\left[k\right]}} &= \textrm{atan2} \left( {\frac{-\mathbf{f}_{x}\left[k\right] }{ \sqrt{ {\left({{-\mathbf{f}_{y}^{2}}\left[k\right]}\right)} + {\left({{-\mathbf{f}}_{z}^{2}}{\left[k\right]}\right)}}}} \right), \quad -\frac{\pi}{2} \leq \theta \leq \frac{\pi}{2} \\
\end{align*}

E os acelerômetros para obter diretamente \(\mathbf{f}^{bf}\), e, indiretamente, \(\mathbf{a}\):
\begin{align*}
    \mathbf{a} &= \dfrac{\mathbf{F}}{m} + \mathbf{G} \equiv \mathbf{f} + \mathbf{G} \\
{^{i}\mathbf{a}^{tp}_{cm/Q}\left[k\right]} &= C_{tp/frd}\left[k\right]{^{i}\mathbf{f}^{frd}_{cm/Q}\left[k\right]} - \mathbf{g}^{tp}.
\end{align*}

Por último, utilizamos os resultados para calcular:
\begin{align*}
    {^{a}{\dot{\mathbf{v}}}^{tp}_{cm/e}{\left[k\right]}}
        &\approx {^{a}{\dot{\mathbf{v}}}^{tp}_{cm/e}}{\left[ k-1 \right]}
        + T \Big( {C_{tp/frd}\left({\Phi}{\left[ k-1 \right]} \right)} {{\mathbf{f}}^{frd}\left[k-1\right]} {-{\mathbf{g}}^{tp}} \Big) \\
    {^{e}{\mathbf{p}^{tp}_{cm/Q}}\left[k\right]}
    &\approx     {^{e}{\mathbf{p}^{tp}_{cm/Q}}\left[k-1\right]}
    + T {^{a}\mathbf{v}^{frd}_{cm/Q}{\left[ k-1 \right]}} \\
\end{align*}

\section{Fusão de sensores}

No nosso caso, podemos utilizar um filtro complementar, bastante simples, para calcular a atitude. O filtro consiste em utilizar simultaneamente dois métodos para obter a estimativa de atitude: a integração das taxas angulares e o cálculo da atitude a partir dos acelerômetros. Ao resultado de cada método é atribuído um peso que representa sua confiabilidade naquele instante, ambos são somados e o resultado final é normalizado. 

Desse modo podemos evitar os resultados divergentes da simples integração de giroscópios e ao mesmo tempo reduzir as oscilações da estimativa pelo ruído dos acelerômetros, o que acaba funcionando como um mecanismo de estabilização das estimativas de atitude.

\section{Testes de bancada para coleta de dados}

Nesta seção apresentamos a realização dos testes.


